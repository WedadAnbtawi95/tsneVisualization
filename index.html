<!DOCTYPE html>
<html lang="en">
<head>
    <title>t-SNE.js</title>
    <meta charset="utf-8"/>
    <script type="text/javascript" charset="UTF-8" src="js/three.js"></script>
    <script type="text/javascript" charset="UTF-8" src="js/TrackballControls.js"></script>
    <script type="text/javascript" src="js/OrbitControls.js"></script>
    <script type="text/javascript" src="js/Stats.js"></script>
    <script type="text/javascript" src="js/dat.gui.js"></script>
    <script type="text/javascript" src="js/util.js"></script>
    <script type="text/javascript" src="js/underscore.js"></script>
    <link rel="stylesheet" href="css/styles.css"/>
</head>
<body onload="init()">
<h1 class="l-middle">Interactive t-SNE</h1>
<div class="container">
    <p style="text-align: left;"> You can upload your own data as csv file with the first column as is label and the
        rest of the columns as features. The label will be used as the color of the datapoint. You can change the view
        using the mouse or using the keys (x,y,z).</p>

    <div class="panel">
        <div id="control-panel" data-sr="enter left over 8s">
            <div class="param">
                <label for="param-perplexity">Database</label>
                <input type="file" id="filechoice" onchange="checkfile(this);"/>
                <output></output>
            </div>
            <div class="param">
                <label for="param-nsamples">Number of Samples</label>
                <input id="param-nsamples" type="range" min="100" max="2000" value="500" step="100">
                <output for="param-nsamples" id="param-nsample-value">500</output>
            </div>
            <div class="param">
                <label for="param-perplexity">Perplexity</label>
                <input id="param-perplexity" type="range" min="5" max="100" value="30" step="1">
                <output for="param-perplexity" id="param-perplexity-value">30</output>
            </div>
            <div class="param">
                <label for="param-earlyexag">Early Exaggeration</label>
                <input id="param-earlyexag" type="range" min="1.1" max="50.0" value="2.1" step="0.1">
                <output for="param-earlyexag" id="param-earlyexag-value">2.1</output>
            </div>
            <div class="param">
                <label for="param-learningrate">Learning Rate</label>
                <input id="param-learningrate" type="range" min="1" max="1000" value="80" step="1">
                <output for="param-learningrate" id="param-learningrate-value">80</output>
            </div>
            <div class="param">
                <label for="param-maxiter">Max Iterations</label>
                <input id="param-maxiter" type="range" min="100" max="1000" value="150" step="10">
                <output for="param-maxiter" id="param-maxiter-value">150</output>
            </div>
            <div class="param">
                <label for="param-dim">3D Dimension</label>
                <input type="checkbox" id="3dModel" checked style="width: 40%; display: inline-block">
                <output></output>
            </div>
            <div id="run-button" onclick="rundraw()">Run</div>
        </div>
        <div id="webgl-output"></div>
    </div>
</div>

<!----------- SCRIPTS ------------>

<script src="js/jquery.min.js"></script>
<script src="js/tsne.min.js"></script>
<script>
    'use strict';
    var N_SAMPLES;
    var worker;
    var count = 0;
    var myReq;
    var nIter;
    var fileuploaded = false;
    var frameId;
    var N_classes;
    var SAMPLE_DATA;
    var SAMPLE_LABELS;
    var stats;
    var lowdim;
    var stars = [];
    var firstRun;
    var camera, scene, renderer, orbitControls, raycaster;
    var mouse, INTERSECTED;
    var points, clock, colors, embeddingSpace;
    var drawCount;
    var update = false;

    function checkfile(sender) {
        var validExt = ".csv";
        var fileExt = sender.value;
        fileExt = fileExt.substring(fileExt.lastIndexOf('.'));
        if (validExt == fileExt) {
            fileuploaded = true;
            return true;
        } else {
            fileuploaded = false;
            alert("Invalid file selected, valid files are of " + validExt + " type.");
            return false;
        }
    }

    function getRandomColor() {
        var letters = '012345'.split('');
        var color = '#';
        color += letters[Math.round(Math.random() * 5)];
        letters = '0123456789ABCDEF'.split('');
        for (var i = 0; i < 5; i++) {
            color += letters[Math.round(Math.random() * 15)];
        }
        return color;
    }

    function render() {
        orbitControls.update(clock.getDelta());
        requestAnimationFrame(render);
        if ((lowdim == 2) && (drawCount == 1)) {
            points.geometry.attributes.position.needsUpdate = true; // required after the first render
        }
        renderer.render(scene, camera)
    }

    function init() {
        firstRun = true;
        update = true;
        drawCount = 0;
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        var light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1).normalize();
        scene.add(light);
        embeddingSpace = document.getElementById('webgl-output');
        camera = new THREE.PerspectiveCamera(100, embeddingSpace.clientWidth / embeddingSpace.clientWidth, 1, 10);
        camera.position.set(0, 2, 0);
        raycaster = new THREE.Raycaster();
        // initialize object to perform world/screen calculations
        mouse = new THREE.Vector2();
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xffffff, 1);
        renderer.setSize(embeddingSpace.clientWidth, embeddingSpace.clientWidth);
        orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
        embeddingSpace.appendChild(renderer.domElement);
        renderer.render(scene, camera);
        var trackballControls = new THREE.TrackballControls(camera, renderer.domElement);
        render();
        document.addEventListener("keydown", onDocumentKeyDown, false);

        //document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        function onDocumentKeyDown(event) {
            var keyCode = event.which;
            if (keyCode == 88) {
                camera.position.set(2, 0, 0);
            } else if (keyCode == 89) {
                camera.position.set(0, 2, 0);
            } else if (keyCode == 90) {
                camera.position.set(0, 0, 2);
            } else if (keyCode == 79) {
                camera.position.set(1, 1, 1);
            }
        };

    }

    function onDocumentMouseDown(event) {
        var mouse3D = new THREE.Vector2(event.clientX / embeddingSpace.clientWidth * 2 - 1,
            -(event.clientY / embeddingSpace.clientHeight) * 2 + 1);
        console.log(mouse3D);
        mouse3D.sub(camera.position);
        mouse3D.normalize();
        raycaster.setFromCamera(mouse3D, camera);
        // find intersections
        var geometry = points.geometry;
        var attributes = geometry.attributes;
        var intersects = raycaster.intersectObjects(points, true);
        // Change color if hit block
        if (intersects.length > 0) {
            console.log("Hit @ " + attributes.label.array[INTERSECTED]);
            INTERSECTED = intersects[0].index;
        }
    }

    function toString(v) {
        return "[ " + v.x + ", " + v.y + ", " + v.z + " ]";
    }

    function componentToHex(c) {
        var hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
    }

    function rgbToHex(r, g, b) {
        return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
    }

    function draw(num) {
        Array.prototype.unique = function () {
            return this.filter(function (value, index, self) {
                return self.indexOf(value) === index;
            });
        }

        function _draw(SAMPLE_DATA, SAMPLE_LABELS) {
            var sampleData = SAMPLE_DATA;
            var sampleLabels = SAMPLE_LABELS;
            var labels = sampleLabels.unique();
            var colorsLabels = [];
            for (var i = 0; i < labels.length; i++) {
                var j = 0;
                var newcolor = [Math.random() * 0.9, Math.random() * 0.9, Math.random() * 0.9];
                while (j < colorsLabels.length) {
                    //check if the new color is already in the colorslabels array
                    if (_.isEqual(newcolor, colorsLabels.slice(j, j + 3))) {
                        j = 0;
                        newcolor = [Math.random() * 0.9, Math.random() * 0.9, Math.random() * 0.9];
                    } else {
                        j = j + 3;
                    }
                }
                colorsLabels = colorsLabels.concat(newcolor);
            }
            var positions = [];
            var info = [];
            colors = [];
            var color = new THREE.Color();
            if (lowdim == 3) {
                var geometry = new THREE.BoxGeometry(0.04, 0.04, 0.04);
                for (var i = 0; i < num; i++) {
                    var label = labels.indexOf(sampleLabels[i]);
                    var color = new THREE.Color(colorsLabels[label * 3], colorsLabels[label * 3 + 1], colorsLabels[label * 3 + 2]);
                    var material = new THREE.MeshBasicMaterial({color: color});
                    var mesh = new THREE.Mesh(geometry, material);
                    mesh.position.x = Math.random() * (-2) + 1;
                    mesh.position.y = Math.random() * (-2) + 1;
                    mesh.position.z = Math.random() * (-2) + 1;
                    mesh.userData.tooltipText = "uuid: " + mesh.uuid + " color: " + label + " x: " + mesh.position.x + " y: " + mesh.position.y + " z: " + mesh.position.z;
                    stars.push(mesh);
                    scene.add(mesh);
                }
            } else {
                //var starsGeometry = new THREE.Geometry();
                for (var i = 0; i < num; i++) {
                    var geometry = new THREE.BufferGeometry();
                    var positions = [];
                    var info = [];
                    colors = [];
                    var color = new THREE.Color();
                    for (var i = 0; i < num; i++) {
                        // positions
                        var x = 0;
                        var y = 0;
                        var z = 0;
                        positions.push(x, y, z);
                        // colors
                        info.push(sampleLabels[i]);
                        var label = labels.indexOf(sampleLabels[i]);
                        colors.push(colorsLabels[label * 3], colorsLabels[label * 3 + 1], colorsLabels[label * 3 + 2]);
                    }
                    geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                    geometry.addAttribute('label', new THREE.Float32BufferAttribute(info, 1));
                    geometry.computeBoundingSphere();
                    var texture = new THREE.TextureLoader().load('textures/circle.png');
                    var material = new THREE.PointsMaterial({
                        size: 0.05,
                        vertexColors: THREE.VertexColors,
                        map: texture,
                        transparent: true,
                        depthWrite: false
                    });
                    points = new THREE.Points(geometry, material);
                    scene.add(points);

                    drawCount = 1;
                }
            }
            //var opt = {}
            var perplexity = parseInt($('#param-perplexity').val());
            var earlyExaggeration = parseFloat($('#param-earlyexag').val());
            var epsilon = parseInt($('#param-learningrate').val());
            var dim = lowdim; // dimensionality of the embedding (2 = default)
            console.log(sampleData);
            worker.postMessage({
                type: 'INPUT_DATA',
                data: sampleData
            });
            worker.postMessage({
                type: 'RUN',
                data: {
                    perplexity: perplexity,
                    earlyExaggeration: earlyExaggeration,
                    learningRate: epsilon,
                    nIter: nIter,
                    dim: dim
                }
            });
        }

        if (SAMPLE_DATA) {
            _draw(SAMPLE_DATA, SAMPLE_LABELS);
        } else {
            read();

            function read() {
                var fr = new FileReader();
                fr.onload = function () {
                    document.getElementById('contents').textContent = this.result;
                };
                fr.readAsText(document.getElementById('filechoice').files[0]);
                fr.onload = loadHandler;
            };

            function loadHandler(event) {
                var csv = event.target.result;
                processData(csv);
            }

            function processData(csv) {
                var allTextLines = csv.split(/\r\n|\n/);
                var lines = [];
                var labels = [];
                var sampledata = [];
                for (var i = 1; i < N_SAMPLES + 1; i++) {
                    var row = allTextLines[i].split(',');
                    labels.push(row[0]);
                    sampledata.push(row.slice(1).map(function (item) {
                        return parseInt(item, 10);
                    }));
                }
                SAMPLE_DATA = sampledata;
                SAMPLE_LABELS = labels;
                _draw(SAMPLE_DATA, SAMPLE_LABELS);
            }
        }

    }

    function clearScene() {
        var to_remove = [];
        scene.traverse(function (child) {
            to_remove.push(child);
        });
        for (var i = 0; i < to_remove.length; i++) {
            scene.remove(to_remove[i]);
        }
    }

    function drawUpdate(embedding) {
        var newPos = [];
        for (var i = 0; i < embedding.length; i++) {
            // positions
            var x = embedding[i][0];
            var y = embedding[i][1];
            var z = (lowdim == 3) ? embedding[i][2] : 0;
            newPos.push(x, y, z);
            if (lowdim == 3) {
                stars[i].position.x = x;
                stars[i].position.y = y;
                stars[i].position.z = z;
            }
        }
        if (lowdim == 2) {
            points.geometry.attributes.position = new THREE.Float32BufferAttribute(newPos, 3);
        }
        renderer.render(scene, camera);
    };

    function stopWorker() {
        worker.terminate();
        worker = undefined;
    }

    function rundraw() {
        if (fileuploaded && update) {
            if (firstRun == false) {
                stopWorker();
            }
            firstRun = false;
            stars = [];
            points = null;
            worker = new Worker('js/worker.js');
            nIter = parseInt($('#param-maxiter').val());
            clearScene();
            count = 0;
            N_SAMPLES = parseInt($('#param-nsamples').val());
            var threeDModel = $('#3dModel').prop('checked');
            lowdim = threeDModel ? 3 : 2;
            worker.onmessage = function (e) {
                var msg = e.data;
                switch (msg.type) {
                    case 'PROGRESS_STATUS':
                        $('#progress-status').text(msg.data);
                        break;
                    case 'PROGRESS_ITER':
                        break;
                    case 'PROGRESS_DATA':
                        drawCount++;
                        drawUpdate(msg.data);
                        break;
                    case 'DONE':
                        drawCount++;
                        drawUpdate(msg.data);
                        break;
                    default:
                }
            }
            draw(N_SAMPLES);
            render();

            function render() {
                orbitControls.update(clock.getDelta());
                requestAnimationFrame(render);
                if ((lowdim == 2) && (drawCount == 1)) {
                    points.geometry.attributes.position.needsUpdate = true; // required after the first render
                }
                renderer.render(scene, camera)
            }
        }
    }

    $('#param-nsamples').bind('input', function () {
        $('#param-nsample-value').text($('#param-nsamples').val());
    });
    $('#param-perplexity').bind('input', function () {
        $('#param-perplexity-value').text($('#param-perplexity').val());
    });
    $('#param-earlyexag').bind('input', function () {
        $('#param-earlyexag-value').text($('#param-earlyexag').val());
    });
    $('#param-learningrate').bind('input', function () {
        $('#param-learningrate-value').text($('#param-learningrate').val());
    });
    $('#param-maxiter').bind('input', function () {
        $('#param-maxiter-value').text($('#param-maxiter').val());
    });


    // this will be 2D coordinates of the current mouse position, [0,0] is middle of the screen.
    var mouse = new THREE.Vector2();

    var latestMouseProjection; // this is the latest projection of the mouse on object (i.e. intersection with ray)
    var hoveredObj; // this objects is hovered at the moment

    // tooltip will not appear immediately. If object was hovered shortly,
    // - the timer will be canceled and tooltip will not appear at all.
    var tooltipDisplayTimeout;

    // This will move tooltip to the current mouse position and show it by timer.

    function showTooltip() {
        var divElement = $("#tooltip");

        if (divElement && latestMouseProjection) {
            divElement.css({
                display: "block",
                opacity: 0.0
            });

            var canvasHalfWidth = renderer.domElement.offsetWidth / 2;
            var canvasHalfHeight = renderer.domElement.offsetHeight / 2;

            var tooltipPosition = latestMouseProjection.clone().project(camera);
            tooltipPosition.x = (tooltipPosition.x * canvasHalfWidth) + canvasHalfWidth + renderer.domElement.offsetLeft;
            tooltipPosition.y = -(tooltipPosition.y * canvasHalfHeight) + canvasHalfHeight + renderer.domElement.offsetTop;

            var tootipWidth = divElement[0].offsetWidth;
            var tootipHeight = divElement[0].offsetHeight;

            divElement.css({
                left: `${tooltipPosition.x - tootipWidth / 2}px`,
                top: `${tooltipPosition.y - tootipHeight - 5}px`
            });

            // var position = new THREE.Vector3();
            // var quaternion = new THREE.Quaternion();
            // var scale = new THREE.Vector3();
            // hoveredObj.matrix.decompose(position, quaternion, scale);
            divElement.text(hoveredObj.userData.tooltipText);

            setTimeout(function () {
                divElement.css({
                    opacity: 1.0
                });
            }, 25);
        }
    }

    // This will immediately hide tooltip.
    function hideTooltip() {
        var divElement = $("#tooltip");
        if (divElement) {
            divElement.css({
                display: "none"
            });
        }
    }

    // Following two functions will convert mouse coordinates
    function updateMouseCoords(event, coordsObj) {

        var rect = renderer.domElement.getBoundingClientRect();
        coordsObj.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        coordsObj.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function handleManipulationUpdate() {
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(scene.children);
        if (intersects.length > 0) {
            latestMouseProjection = intersects[0].point;
            hoveredObj = intersects[0].object;
        }

        if (tooltipDisplayTimeout || !latestMouseProjection) {
            clearTimeout(tooltipDisplayTimeout);
            tooltipDisplayTimeout = undefined;
            hideTooltip();
        }

        if (!tooltipDisplayTimeout && latestMouseProjection) {
            tooltipDisplayTimeout = setTimeout(function () {
                tooltipDisplayTimeout = undefined;
                showTooltip();
            }, 330);
        }
    }

    function onMouseMove(event) {
        updateMouseCoords(event, mouse);

        latestMouseProjection = undefined;
        hoveredObj = undefined;
        handleManipulationUpdate();
    }

    document.getElementById("webgl-output").addEventListener('click', onMouseMove, false);


</script>
<dt-appendix>
    <style>
        dt-appendix {
            display: block;
            font-size: 14px;
            line-height: 24px;
            margin-bottom: 0;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            color: rgba(0, 0, 0, 0.5);
            background: rgb(250, 250, 250);
            padding-top: 36px;
            padding-bottom: 60px;
        }

        dt-appendix h3 {
            font-size: 16px;
            font-weight: 500;
            margin-top: 18px;
            margin-bottom: 18px;
            color: rgba(0, 0, 0, 0.65);
        }

        dt-appendix .citation {
            font-size: 11px;
            line-height: 15px;
            border-left: 1px solid rgba(0, 0, 0, 0.1);
            padding-left: 18px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background: rgba(0, 0, 0, 0.02);
            padding: 10px 18px;
            border-radius: 3px;
            color: rgba(150, 150, 150, 1);
            overflow: hidden;
            margin-top: -12px;
        }

        dt-appendix .references {
            font-size: 12px;
            line-height: 20px;
        }

        dt-appendix a {
            color: rgba(0, 0, 0, 0.6);
        }

        dt-appendix ol,
        dt-appendix ul {
            padding-left: 24px;
        }
    </style>
    <dt-appendix>
        <h3>Acknowledgments</h3>
        <p>Authors: Wedad Anbtawi and Mohamed Nassar.
        <p>This work was made possible by the support of the <a href="https://aub.edu.lb">American University of
            Beirut</a>.</p>
    </dt-appendix>
    <div class="l-body">
        <h3>References</h3>
        <dt-bibliography>
            <ol>
                <li><b>Visualizing data using t-SNE</b>
                    &ensp;<a href="http://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf">[PDF]</a>
                    <br>Maaten, L.v.d. and Hinton, G., 2008. Journal of Machine Learning Research, Vol 9(Nov), pp.
                    2579—2605.
                </li>
            </ol>
        </dt-bibliography>

        <div id="tooltip"></div>


        <style>

            #tooltip {
                position: fixed;
                left: 0;
                top: 0;
                min-width: 100px;
                text-align: center;
                padding: 5px 12px;
                font-family: monospace;
                background: #a0c020;
                display: none;
                opacity: 0;
                border: 1px solid black;
                box-shadow: 2px 2px 3px rgba(0, 0, 0, 0.5);
                transition: opacity 0.25s linear;
                border-radius: 3px;
            }

        </style>

        <script src="js/scrollReveal.min.js"></script>
        <script>
            (function () {
                window.sr = new scrollReveal({
                    reset: true,
                    mobile: true,
                    vFactor: 0.2
                });
            })();
        </script>
</body>
</html>

